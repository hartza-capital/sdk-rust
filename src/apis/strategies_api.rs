/*
 * API Hartza Capital
 *
 * ## Welcome to the Hartza Capital API documentation  This comprehensive financial data API provides access to market information, portfolio management capabilities, and sophisticated trading tools.  For production use, an OAuth2 token is required. After authentication, you'll receive a token with a 15-minute lifespan.  When this period expires, please use your refresh token to obtain a new access token. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@hartza.capital
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`options_strategies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptionsStrategiesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`options_strategy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptionsStrategyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`strategies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StrategiesError {
    Status400(models::Orders400Response),
    Status401(models::Orders401Response),
    Status404(models::Account404Response),
    Status500(models::Orders500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`strategy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StrategyError {
    Status400(models::Orders400Response),
    Status401(models::Orders401Response),
    Status404(models::Account404Response),
    Status500(models::Orders500Response),
    UnknownValue(serde_json::Value),
}


/// Options method is used to describe the communication options for the targeted resource.
pub async fn options_strategies(configuration: &configuration::Configuration, ) -> Result<(), Error<OptionsStrategiesError>> {

    let uri_str = format!("{}/v1/strategies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::OPTIONS, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OptionsStrategiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Options method is used to describe the communication options for the targeted resource.
pub async fn options_strategy(configuration: &configuration::Configuration, strategy: &str) -> Result<(), Error<OptionsStrategyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_strategy = strategy;

    let uri_str = format!("{}/v1/strategy/{strategy}", configuration.base_path, strategy=crate::apis::urlencode(p_strategy));
    let mut req_builder = configuration.client.request(reqwest::Method::OPTIONS, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OptionsStrategyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permits to list strategies for the account
pub async fn strategies(configuration: &configuration::Configuration, items: i64, page: i64) -> Result<models::Strategies200Response, Error<StrategiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_items = items;
    let p_page = page;

    let uri_str = format!("{}/v1/strategies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("items", &p_items.to_string())]);
    req_builder = req_builder.query(&[("page", &p_page.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Strategies200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Strategies200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StrategiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permits to get properties of strategy for the account
pub async fn strategy(configuration: &configuration::Configuration, strategy: &str) -> Result<models::V1StrategyResponse, Error<StrategyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_strategy = strategy;

    let uri_str = format!("{}/v1/strategy/{strategy}", configuration.base_path, strategy=crate::apis::urlencode(p_strategy));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::V1StrategyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::V1StrategyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StrategyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

