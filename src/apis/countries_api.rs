/*
 * API Hartza Capital
 *
 * ## Welcome to the Hartza Capital API documentation  This comprehensive financial data API provides access to market information, portfolio management capabilities, and sophisticated trading tools.  For production use, an OAuth2 token is required. After authentication, you'll receive a token with a 15-minute lifespan.  When this period expires, please use your refresh token to obtain a new access token. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@hartza.capital
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`country`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountryError {
    Status400(models::Orders400Response),
    Status401(models::Orders401Response),
    Status404(models::Account404Response),
    Status500(models::Orders500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`country_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountryEventsError {
    Status400(models::Orders400Response),
    Status401(models::Orders401Response),
    Status404(models::Account404Response),
    Status500(models::Orders500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`options_country`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptionsCountryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`options_country_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptionsCountryEventsError {
    UnknownValue(serde_json::Value),
}


/// Permits to get the country properties
pub async fn country(configuration: &configuration::Configuration, ticker: &str) -> Result<models::Country200Response, Error<CountryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ticker = ticker;

    let uri_str = format!("{}/v1/country/{ticker}", configuration.base_path, ticker=crate::apis::urlencode(p_ticker));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Country200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Country200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CountryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permits to get the macro economic events for the targeted country
pub async fn country_events(configuration: &configuration::Configuration, ticker: &str) -> Result<models::CountryEvents200Response, Error<CountryEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ticker = ticker;

    let uri_str = format!("{}/v1/country/{ticker}/events", configuration.base_path, ticker=crate::apis::urlencode(p_ticker));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CountryEvents200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CountryEvents200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CountryEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Options method is used to describe the communication options for the targeted resource.
pub async fn options_country(configuration: &configuration::Configuration, ticker: &str) -> Result<(), Error<OptionsCountryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ticker = ticker;

    let uri_str = format!("{}/v1/country/{ticker}", configuration.base_path, ticker=crate::apis::urlencode(p_ticker));
    let mut req_builder = configuration.client.request(reqwest::Method::OPTIONS, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OptionsCountryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Options method is used to describe the communication options for the targeted resource.
pub async fn options_country_events(configuration: &configuration::Configuration, ticker: &str) -> Result<(), Error<OptionsCountryEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ticker = ticker;

    let uri_str = format!("{}/v1/country/{ticker}/events", configuration.base_path, ticker=crate::apis::urlencode(p_ticker));
    let mut req_builder = configuration.client.request(reqwest::Method::OPTIONS, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OptionsCountryEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

